### pthread_create(&t, NULL, read_func, (void*)&RI);
// for structs we have to &RI, for primitives ie int we dont

### struct readerInfo ri = (struct readerInfo)args;
struct readerInfo *ri = (struct readerInfo*)args;

### char* booknames[];
char** booknames;
int books;

switch (choice) {
    case 1: {
        pthread_t t;  // Now it's scoped to this block only
        // Your code...
        break;
    }

    case 2: {
        pthread_t t;  // Allowed again because it's in a different block
        // Your code...
        break;
    }

    // other cases...
}

/*
        after the wait, all the books this reader requested will be checked, on each book being available
        the book will be marked borrowed by the writer_modify and while that happens other threads will be paused
        write operation can be done in miliseconds and it doesnt really matter if we put a lock for that, but we will incorporate sleep just to show the mutex functionality and synchronization
        so does the sleep also pause during the lock, since each reader is calling this write_modify, it is actually the parent, so does the parent halt too?
        write_modify will have this lock that stops the reader threads to proceed during that time
*/

// entire system sleep or just this thread? - just this
// in posix only the calling thread sleeps

 while(fgets(line, sizeof(line), fr)){
            // fgets remembers where it left off
}

line[strcspn(line, '\n')] = '\0'; // strcspn works like a if condition, checks where \n is and returns that position

char* bookname = strtok(line, " "); // starts at start of line and cuts at the delimiter
char* authorname = strtok(NULL, " "); // null tells it to remember where it left off, continues from there
char *pages = strtok(NULL, " ");   
char *borrowed = strtok(NULL, " ");
